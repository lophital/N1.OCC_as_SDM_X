---
title: "Title"
description: |
  Population affect Response function, SDM, Occurrence
author:
  - name: Cheongok Jeon 
    url: https://github.com/lophital
    affiliation: Seoul National University, Korea
    affiliation_url: https://geog.snu.ac.kr/
    orcid_id: 0000-0002-9950-6794
  - name: Daehyun Kim
    affiliation: Seoul National University, Korea
    affiliation_url: https://geog.snu.ac.kr/
    orcid_id: 0000-0001-9239-5895
twitter: 
  site: "@lophital"
  creator: "@lophital"
journal: 
  title: "Ecography"
  pasge: "1-27"
  # issn: 2490-1752
  # publisher: ESA
# volume: 44
# issue: 4
doi: "10.1002/ecm.1486"
date: "2023-1-1"
bibliography: references.bib
bib-humanities: true
output: 
  distill::distill_article:
    toc: true
    toc_depth: '2'
    theme: theme.css
creative_commons: CC BY
header-includes: 
  \usepackage{caption}
  \renewcommand{\figurename}{Fig.} 
  \renewcommand{\thefigure}{S\arabic{figure}} 
  \renewcommand{\thetable}{S\arabic{table}}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)
```


# Pre
## load things
```{r}
library(tidyverse)
library(sf)
library(tmap)
library(virtualspecies)
library(raster)
library(spatstat)
library(SDMtune)
library(precrec)
library(Metrics)
library(prg)
library(rasterVis)
```



## conflict
```{r}
conflicted::conflict_prefer(name = "select", winner = "dplyr")
conflicted::conflict_prefer(name = "filter", winner = "dplyr")
#conflicted::conflict_prefer(name = "stack", winner = "raster")
#conflicted::conflict_prefer(name = "stack", winner = "utils")
conflicted::conflict_prefer(name = "auc", winner = "SDMtune")
```


# Intro
## env.var - bioclimate 
```{r}
list.files(path = paste(system.file(package = "dismo"),
                        "/ex", sep = ''),
           pattern = "grd",
           full.names = TRUE) %>%
  str_subset("biome", negate = TRUE) %>%
  .[c(1,5,6,7,8,2,3,4)] %>%
  raster::stack() -> bioclim
bioclim
```

Fix names and order

```{r}
names(bioclim) <- c("bio01", "bio05", "bio06", "bio07", "bio08", "bio12", "bio16", "bio17")
Xs <- bioclim
Xs.name <- names(Xs)
Xs
```
```{r}
# standardization
for(i in 1:nlayers(Xs)){
(Xs[[i]] - cellStats(Xs[[1]], mean)) / cellStats(Xs[[i]], sd) -> Xs[[i]]
}


my.rescale <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = raster::minValue(x)
  if(is.null(x.max)) x.max = raster::maxValue(x)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}

my.rescale.vc <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = base::min(x, na.rm = TRUE)
  if(is.null(x.max)) x.max = base::max(x, na.rm = TRUE)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}

# normalization
for(i in 1:nlayers(Xs)){
  my.rescale(Xs[[i]]) -> Xs[[i]]
}

Xs

```

```{r}

rasterVis::levelplot(Xs, par.settings = viridisTheme(), contour = FALSE)
#png(filename = "test.png",res = 300) if saving is needed
#dev.off()
```

```{r}
is.na(Xs[[1]]) -> raster.blank
!is.na(Xs[[1]]) -> raster.fill

which(as.vector(raster.fill)) -> vc.filled

as.vector(raster.blank) %>% length()
```


env.var - neutral landscape(보류)

my.gfd <- function(){
NLMR::nlm_gaussianfield(ncol = 1000, nrow = 1000,
                        resolution = 1,
                        autocorr_range = 100, # range of SAC
                        mag_var = 1,
                        nug = 0,
                        mean = 0,
                        rescale = T)}



Xs <- list()
for(i in 1:3){
  set.seed(i)
  my.gfd() -> Xs[[i]]
}
stack(Xs) -> Xs







plot(Xs[[1]])




what is this
set.seed(4)
my.gfd() -> Xpop
apop <- 2
sigma_01 <- 0.5
mu_01 <- 0.6
X1 <- abs(Xpop*apop+sigma_01)*(sqrt(-2*log(sqrt(2*pi)*Xpop*(Xpop*apop+sigma_01))))+mu_01

plot(sqrt(2*pi)*(Xpop*(Xpop*apop+sigma_01)) <= 1)




calc(Xpop, function(x, mu_01, Xpop, apop, sigma_01){
  dnorm(x = x,
        mean = mu_01, 
        sd = Xpop*apop+sigma_01)
})



기존의 연구 방식은 환경 변수 Xs에 의해 Xpop 혹은 HS가 결정되는 방식이다.
이를 위해서는 Xpop(좌항)을 환경 변수 Xs에 대한 식(우항)으로 정리할 수 있어야 한다.
하지만 본 연구에서 제기하는 상황(Xpop이 방정식 좌우항에 포함되는 상황)에서는 식의 정리가 어렵다.
가능한 것은
상황을 만족하는 X1과 Xpop을 구하는 것 뿐이다.

X1에 따른 Xpop을 구하는 방법은 다음과 같다.
1. Xs 를 무작위로 선정한다.
2-1. apop_n, sigma_n, mu_01을 선정한다.
3. 방정식에 최대한 근접하는 Xpop을 추정한다.

몬테카를로 방식은 다음과 같다.
1. 샘플수를 선정
2. 구하고자 하는 Xpop의 범위를 선정
3. 
# 2. Unimodal

## 2.1 parameters

영향을 받은 변수는 prime,
영향을 받지 않는 변수는 dprime으로 구분한다.


addTaskCallback(function(...) {set.seed(123);TRUE})




```{r MC ineqauation}
## SET.SEED
set.seed(1)

## param range
mu.range <- seq(0.1, 0.9, by = 0.1)
a.range <- seq(0.1, 0.9, by = 0.1)
b.range <- seq(0.1, 0.9, by = 0.1)
sigma.range <- seq(0.1, 0.9, by = 0.1)
apop.range <- seq(0.1, 0.9, by = 0.1)
e.variable.n.range <- 2:8 # 몇개의 환경 변수를 뽑을 것인가?
e.variable.name.range <- 1:8 # 어떤 환경 변수를 뽑을 것인가?

## parameter sampling
mu <- sample(mu.range, 1)
sigma <- sample(sigma.range, 1)
sigma.dprime <- sample(sigma.range, 1)
a <- sample(a.range, 1)
apop.prime <- sample(apop.range, 1)
apop.dprime <- sample(apop.range, 1)
b <- sample(b.range, 1)
```


```{r}
## variable selection
set.seed(1)
Xs.choosen <- Xs[[sort(sample(e.variable.name.range, sample(e.variable.n.range, 1)))]]
nlayers(Xs.choosen)
Xs.choosen
```

```{r}
Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))

## Formulas
forms.gaus.prime <- function(Xs){ # prime
  ((1/sqrt(2*pi)*(Xpop*apop.prime + sigma.dprime))*exp(1)^(-(Xs[i]-mu)^2/2*((Xpop*apop.prime + sigma.dprime))^2)) -> vc
  idx.over <- vc > 1
  idx.lower <- vc < 0
  vc[idx.over] <- 1
  vc[idx.lower] <- 0
  return(vc)
}


forms.gaus <- function(Xs){
  ((1/sqrt(2*pi)*sigma)*exp(1)^(-(Xs[i]-mu)^2/2*(sigma)^2)) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms.linear.prime <- function(Xs){ # prime
  ((Xpop*apop.prime + apop.dprime)*Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

# ifelse is slow.
# vectorization :)

forms.linear <- function(Xs){
  (a *Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms <- list(forms.gaus, forms.gaus.prime, forms.linear, forms.linear.prime)



## MC equation
#inequation <- abs((forms.gaus.prime(Xs[[1]])) + forms.gaus(Xs[[2]]) - Xpop) < 0.0001
#length(Xpop[inequation])
#Xpop[inequation]


map2(sample(forms, nlayers(Xs.choosen), replace = TRUE), # which formula to apply
     map(as.list(Xs.choosen), function(x){list(Xs = x)}),  # supply choosen variables as list
     function(fn, args){exec(fn, !!!args)}) -> test 
#map_dbl(test, length)
  as.data.frame(test) %>% 
    rowSums() -> test
  
inequation <- abs(test - Xpop) < 0.0001
length(Xpop[inequation])
hist(Xpop[inequation], 100)
Xpop[inequation]

```



```{r Testing foreach to raster level-range set}
## param range
mu.range <- seq(0.1, 0.9, by = 0.1)
a.range <- seq(0.1, 0.9, by = 0.1)
b.range <- seq(0.1, 0.9, by = 0.1)
sigma.range <- seq(0.1, 0.9, by = 0.1)
apop.range <- seq(0.1, 0.9, by = 0.1)
e.variable.n.range <- 2:8 # 몇개의 환경 변수를 뽑을 것인가?
e.variable.name.range <- 1:8 # 어떤 환경 변수를 뽑을 것인가?

## Formulas
forms.gaus.prime <- function(Xs){ # prime
  ((1/sqrt(2*pi)*(Xpop*apop.prime + sigma.dprime))*exp(1)^(-(Xs[i]-mu)^2/2*((Xpop*apop.prime + sigma.dprime))^2)) -> vc
  idx.over <- vc > 1
  idx.lower <- vc < 0
  vc[idx.over] <- 1
  vc[idx.lower] <- 0
  return(vc)
}


forms.gaus <- function(Xs){
  ((1/sqrt(2*pi)*sigma)*exp(1)^(-(Xs[i]-mu)^2/2*(sigma)^2)) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms.linear.prime <- function(Xs){ # prime
  ((Xpop*apop.prime + apop.dprime)*Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

# ifelse is slow.
# vectorization :)

forms.linear <- function(Xs){
  (a *Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms <- list(forms.gaus, forms.gaus.prime, forms.linear, forms.linear.prime)

acc.lim <- rev(seq(from = 0.00000001, to = 0.0001, by = 0.0000005))
r.vector <- vector()
```

## parallel 
```{r}
library(parallel) #parallel computing
library(foreach)
library(doParallel)

cores <- 60
cluster <- parallel::makeCluster(spec = cores, outfile="")
doParallel::registerDoParallel(cl = cluster)
```


시딩을 먼저 하고.
채워진 모든 셀 i에 대하여

시딩에 따른 계수
시딩에 따른 공식
을 적용해 좌변을 만든다. -> Test

좌변 - xpop이 0.1보다 적은지 테스트 하는 과정(while)

```{r Testing foreach to raster level-functional}
Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))
acc.lim <- rev(seq(from = 0.00000001, to = 0.0001, by = 0.0000005))
##############
## FOR EACH ##
##############

foreach(seed = 1:2, .packages = c("magrittr", "purrr", "raster")) %:% 
  foreach(i = vc.filled) %dopar% {
set.seed(seed)
## parameter sampling
mu <- sample(mu.range, 1)
sigma <- sample(sigma.range, 1)
sigma.dprime <- sample(sigma.range, 1)
a <- sample(a.range, 1)
apop.prime <- sample(apop.range, 1)
apop.dprime <- sample(apop.range, 1)
b <- sample(b.range, 1)


## variable selection
Xs.choosen <- Xs[[sort(sample(e.variable.name.range, sample(e.variable.n.range, 1)))]]
#Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))
.GlobalEnv$Xpop <- Xpop
.GlobalEnv$apop.prime <- apop.prime
.GlobalEnv$sigma.dprime <- sigma.dprime
.GlobalEnv$i <- vc.filled
.GlobalEnv$mu <- mu
.GlobalEnv$sigma <- sigma
.GlobalEnv$a <- a
.GlobalEnv$apop.dprime <- apop.dprime
.GlobalEnv$b <- b
.GlobalEnv$acc.lim <- acc.lim

map2(sample(forms, nlayers(Xs.choosen), replace = TRUE), # which formula to apply
     map(as.list(Xs.choosen), function(x){list(Xs = x)}),  # supply choosen variables as list
     function(fn, args){exec(fn, !!!args)}) -> test
     as.data.frame(test) %>% 
     rowSums() -> test

j <- 1
inequation <- abs(test - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4 && j == length(acc.lim)-1){
    j <- j+1
inequation <- abs(test - Xpop) < acc.lim[j]
}
mean(Xpop[inequation])} -> r.vector
map_dbl(r.vector, rbind) -> r.vector.test
```

```{r Testing foreach - Does it work on for loop?}
r.vector <- vector()
set.seed(1)
for(i in vc.filled){
## parameter sampling
mu <- sample(mu.range, 1)
sigma <- sample(sigma.range, 1)
sigma.dprime <- sample(sigma.range, 1)
a <- sample(a.range, 1)
apop.prime <- sample(apop.range, 1)
apop.dprime <- sample(apop.range, 1)
b <- sample(b.range, 1)


## variable selection
Xs.choosen <- Xs[[sort(sample(e.variable.name.range, sample(e.variable.n.range, 1)))]]
Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))


map2(sample(forms, nlayers(Xs.choosen), replace = TRUE), # which formula to apply
     map(as.list(Xs.choosen), function(x){list(Xs = x)}),  # supply choosen variables as list
     function(fn, args){exec(fn, !!!args)}) -> test
     as.data.frame(test) %>% 
     rowSums() -> test

j <- 1
inequation <- abs(test - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4 && j == length(acc.lim)-1){
    j <- j+1
inequation <- abs(test - Xpop) < acc.lim[j]}
mean(Xpop[inequation]) -> r.vector[i]}


map_dbl(r.vector, rbind) -> r.vector.test
```

```{r}
# once r.vector.test is caculated.
raster::values(raster.blank) <- r.vector.test
raster.blank
plot(raster.blank)

```


# 01 refer not effected
# 1 refer effected first env variable

apop_1 <- 2
sigma_1 <- 0.2
mu_01 <- 0.2
sigma_02 <- 0.3
mu_02 <- 0.3


#Xpop = (1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
#       (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]]-mu_02)^2/2*(sigma_02)^2)


runs <- 100000
Xpop <- runif(runs, min = 0, max = 1)






MC fitting of Xpop
```{r}
set.seed(1)
### what
#acc.lim <- rev(seq(from = 0.0000000001, to = 0.0001, by = 0.000000005))
#r.vector <- vector()
#foreach(i = 1:length(Xs[[1]])) %dopar% {
#  j <- 1
#inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
#              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < 0.1
#  while(length(Xpop[inequation]) > 4){
#j <- j+1
#inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
#              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < acc.lim[j]}
#  r.vector[i] <- mean(Xpop[inequation])} -> r.vector

### test
acc.lim <- rev(seq(from = 0.0000000001, to = 0.0001, by = 0.000000005))
acc.lim <- rev(seq(from = 0.00000001, to = 0.0001, by = 0.0000005))
r.vector <- vector()
inequation <- abs(((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2)) +
              ((1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2)) - Xpop) < 0.1

foreach(i = 1:length(Xs[[1]])) %dopar% {
  j <- 1
inequation <- abs(((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2)) +
              ((1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2)) - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4 && j == length(acc.lim)-1){
j <- j+1
inequation <- abs(((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2)) +
              ((1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2)) - Xpop) < acc.lim[j]}
  mean(Xpop[inequation])} -> r.vector # 양옆으로 날개침 고쳐봄... 안되면 1000 NLMR 쓰지말것... 

map_dbl(r.vector, rbind) -> r.vector.test
#matrix(r.vector.test, nrow = 1000, ncol = 1000) %>% raster() -> test

```




```{r}

par(mfrow = c(1,3))
plot(Xs[[1]])
plot(Xs[[2]])
plot(test)
```




```{r}


for(i in 1:length(Xs[[1]])){
  j <- 0
inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4){
j <- j+1
inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < acc.lim[j]}
  r.vector[i] <- mean(Xpop[inequation])}
  
test <- vector()
## test
for(i in 8){
  j <- 0
inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4){
j <- j+1
inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < acc.lim[j]}
  test[i] <- mean(Xpop[inequation])}
##


inequation <- abs((1/sqrt(2*pi)*(Xpop*apop_1+sigma_1))*exp(1)^(-(Xs[[1]][i]-mu_01)^2/2*((Xpop*apop_1+sigma_1))^2) +
              (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(Xs[[2]][i]-mu_02)^2/2*(sigma_02)^2) - Xpop) < 0.00001

length(Xpop[inequation])


```


```{r}

function(x1, sigma_01, mu01){
  (1/sqrt(2*pi)*sigma_01)*exp(1)^(-(x1-mu_01)^2/2*(sigma_01)^2) +
  (1/sqrt(2*pi)*sigma_02)*exp(1)^(-(x1-mu_02)^2/2*(sigma_02)^2)
}


```





# 무작위 종
1차 샘플링. 몇개의 환경 변수?
```{r}
set.seed(1)
env.Xs <- Xs[[sample(Xs.name, 2)]] #total 2 env variable among 8
```

```{r}
Xpop <- Xs[[1]] # let say Xs[[1]] determine xpop

formatFunctions(layer = c(fun = "my.dnorm",
                          mu_01 = ,
                          Xpop = Xpop,
                          apop = ,
                          sd_1 = )) %>%
  
                #layer.2 = c(fun = "dnorm",
                #            mean = a$details$parameters$layer.2$args[["mean"]],
                #            sd = a$details$parameters$layer.2$args[["sd"]])) %>%
                #layer.3 = c(fun = "dnorm",
                #            mean = a$details$parameters$layer.3$args[["mean"]],
                #            sd = a$details$parameters$layer.3$args[["sd"]])) %>%
map(., 
    function(ff){
      generateSpFromFun(raster.stack = Xs,
                  parameters = ff,
                  rescale = TRUE, #rescale Y
                  rescale.each.response = FALSE, # rescale X
                  formula = NULL, #편반응결합에 쓰인 공식
                  species.type = "multiplicative",
                  plot = TRUE)}) -> a # 표준편차를 달리한 종의 집합(군집별로 달라져야함)


```



```{r}
set.seed(1)
virtualspecies::generateRandomSp(raster.stack = env.Xs,
                                 approach = "response",
                                 rescale = FALSE,
                                 rescale.each.response = FALSE,
                                 convert.to.PA = FALSE,
                                 species.type = "additive",
                                 relations = c("linear")) -> vs.rnd.linear
```

```{r}
set.seed(1)
virtualspecies::generateRandomSp(raster.stack = env.Xs,
                                 approach = "response",
                                 rescale = FALSE,
                                 rescale.each.response = FALSE,
                                 convert.to.PA = FALSE,
                                 species.type = "additive",
                                 relations = c("gaussian")) -> vs.rnd.gaussian
```

#map(seq(0.01, 99.99, by = 0.01), function(KS){
#formatFunctions(layer = c(fun = "dnorm",
#                            mean = a$details$parameters$layer$args[["mean"]],
#                            sd = a$details$parameters$layer$args[["sd"]] * KS))}) -> FF.KS
set.seed(1)
map(seq(0.2,1, by = 0.2), function(x){
  formatFunctions(layer = c(fun = "dnorm",
                            mean = a$details$parameters$layer$args[["mean"]],
                            sd = x))}) %>%
  
                #layer.2 = c(fun = "dnorm",
                #            mean = a$details$parameters$layer.2$args[["mean"]],
                #            sd = a$details$parameters$layer.2$args[["sd"]])) %>%
                #layer.3 = c(fun = "dnorm",
                #            mean = a$details$parameters$layer.3$args[["mean"]],
                #            sd = a$details$parameters$layer.3$args[["sd"]])) %>%
map(., 
    function(ff){
      generateSpFromFun(raster.stack = Xs,
                  parameters = ff,
                  rescale = TRUE, #rescale Y
                  rescale.each.response = FALSE, # rescale X
                  formula = NULL, #편반응결합에 쓰인 공식
                  species.type = "multiplicative",
                  plot = TRUE)}) -> a # 표준편차를 달리한 종의 집합(군집별로 달라져야함)

a[[1]]$suitab.raster



```{r}
seq(0, 0.9, by = 0.1) -> apops
apops
```



```{r}

effected.var <- list()
for(i in 1:nlayers(env.Xs)){
set.seed(1)
effected.var[[i]] <- sample(names(vs.rnd.linear$details$parameters), i)} #2차 샘플링. 어떤 변수가 영향을 받는가?
effected.var

```

```{r}
selected.apop <- list()
for(i in 1:length(effected.var)){
set.seed(1)
selected.apop[[i]] <- sample(apops, length(effected.var[[i]]))} #3차 샘플링. 각 변수는 어떤 계수를 가지는가? 
selected.apop
```

```{r}
set.seed(1)
map(seq(0.2,1, by = 0.2), function(x){
  formatFunctions(layer = c(fun = "dnorm",
                            mean = a$details$parameters$layer$args[["mean"]],
                            sd = x),
                layer.2 = c(fun = "dnorm",
                            mean = a$details$parameters$layer.2$args[["mean"]],
                            sd = a$details$parameters$layer.2$args[["sd"]]),
                layer.3 = c(fun = "dnorm",
                            mean = a$details$parameters$layer.3$args[["mean"]],
                            sd = a$details$parameters$layer.3$args[["sd"]]))}) %>%
map(., 
    function(ff){
      generateSpFromFun(raster.stack = Xs,
                  parameters = ff,
                  rescale = TRUE, #rescale Y
                  rescale.each.response = FALSE, # rescale X
                  formula = NULL, #편반응결합에 쓰인 공식
                  species.type = "multiplicative",
                  plot = TRUE)}) -> a # 표준편차를 달리한 종의 집합(군집별로 달라져야함)
```



```{r}
(1 / (1 - sum(selected.apop[[2]]*env.Xs[[effected.var[[2]]]])))*(
sum((map_dbl(vs.rnd.linear$details$parameters,c("args", "a")) * env.Xs[[effected.var[[2]]]])) + 
sum(map_dbl(vs.rnd.linear$details$parameters,c("args", "b")))
)


```

```{r}
(1/(1-selected.apop[[1]][1]*env.Xs[[1]]-selected.apop[[1]][2]*env.Xs[[2]]))*((a1*env.Xs[[1]])+(a02*env.Xs[[2]]) + b01 + b02) -> test2
```


2차 샘플링- 몇개의 변수가 개체군 영향을 받는가?



```{r}

vs.test <- rep(list(vs.rnd.linear), length(selected.apop))
for(i in 1:length(selected.apop)){
  vs.test[[i]]$suitab.raster <- (1 / (1 - sum(selected.apop[[i]]*env.Xs[[effected.var[[i]]]])))*(
sum((map_dbl(vs.rnd.linear$details$parameters,c("args", "a")) * env.Xs[[effected.var[[i]]]])) + 
sum(map_dbl(vs.rnd.linear$details$parameters,c("args", "b")))
)
}

vs.test.resc <- rep(list(vs.rnd.linear), length(selected.apop))
for(i in 1:length(selected.apop)){
  vs.test.resc[[i]]$suitab.raster <- rescale(vs.test[[i]]$suitab.raster)
}

#vs.lfun$suitab.raster <- (1/(1-apop[i]*Xs[[1]]))*((a1*Xs[[1]])+(a02*Xs[[2]]) + b01 + b02)

#vs.test[[9]]$suitab.raster %>% plot()
#vs.test.resc <- rep(list(vs.rnd), length(apop))
#for(i in 1:length(apop)){
#  vs.test.resc[[i]]$suitab.raster <- rescale((1/(1-apop[i]*Xs[[1]]))*((a1*Xs[[1]])+(a02*Xs[[2]]) + b01 + b02))
#}
```

```{r}
par(mfrow=c(1,2))
plot((1/(1-apop[1]*Xs[[1]])) * vs.lfun$suitab.raster)
plot((1/(1-apop[1]*Xs[[1]])) * vs.lfun$suitab.raster)
plot(vs.lfun$suitab.raster)
vs.rnd$suitab.raster 
rescale <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = min(x)
  if(is.null(x.max)) x.max = max(x)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}
```

```{r}
par(mfrow = c(1,2))
plot(((a1*Xs[[1]])+b01 + (a02*Xs[[2]]) + b02))
plot(vs.rnd$suitab.raster)
```


```{r}
my.rescale <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = raster::minValue(x)
  if(is.null(x.max)) x.max = raster::maxValue(x)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}



my.rescale01 <-
function(x){my.rescale(x = raster,
                    x.min = raster::minValue(raster),
                    x.max = raster::maxValue(raster))}



```

```{r}
par(mfrow=c(1,2)) 
plot(test)
plot(vs.lfun$suitab.raster)
```




```{r}
  geom_raster()
ggplot(aes()) +
```

```{r}
```



#((1/(1-1.3*Xs$layer.1)) * vs.rnd$suitab.raster) -> z
#
#range01 <- function(x){(x-minValue(x))/(maxValue(x)-minValue(x))}
#range01 <- function(x, ...){(x - minValue(x, ...)) / (max(x, ...) - min(x, ...))}
#range01(z) %>% plot()
#range01(z)%>% hist(., breaks = 99)



f
vs.lfun$suitab.raster %>% hist()



set.seed(1)
virtualspecies::generateRandomSp(raster.stack = Xs,
                                 approach = "response",
                                 rescale = T,
                                 convert.to.PA = F,
                                 relations = c("gaussian")) -> a

```{r}
par(mfrow = c(3,3))
plot(vs.rnd$suitab.raster, 
     main = "random VS")
plot(vs.lfun[[1]]$suitab.raster, 
     main = "if X1 is affected by Xpop -0.6(apop)")
plot(vs.lfun[[2]]$suitab.raster, 
     main = "if X1 is affected by Xpop -0.4(apop)")
plot(vs.lfun[[3]]$suitab.raster, 
     main = "if X1 is affected by Xpop -0.2(apop)")
plot(vs.lfun[[4]]$suitab.raster, 
     main = "if X1 is affected by Xpop 0(apop)")
plot(vs.lfun[[5]]$suitab.raster, 
     main = "if X1 is affected by Xpop 0.2(apop)")
plot(vs.lfun[[6]]$suitab.raster, 
     main = "if X1 is affected by Xpop 0.4(apop)")
plot(vs.lfun[[7]]$suitab.raster, 
     main = "if X1 is affected by Xpop 0.6(apop)")
```


```{r}
vs.test %>% map(3) %>% map(rescale) %>%
  map(function(x){
tm_shape(x) +
    tm_raster(legend.show = TRUE,
      legend.is.portrait = FALSE,
              legend.hist = TRUE,
              palette = "viridis") +
    tm_layout(legend.outside = TRUE,
              legend.width = 1.5,
              legend.height = 0.7,
      legend.outside.position = c("bottom"),
      #legend.outside.size = 0.4,
      legend.hist.width = 2,
      legend.hist.size = 1.3,
      legend.text.size = 1,
      frame = FALSE)}) -> tm_test
tm_test[[20]]
```

```{r}
tmap_arrange(tm_test[c(1,6,11,16,20)], ncol = 5, nrow = 1) -> tm_test_all
##tmap_arrange(tm_lfun[[2]],
#             tm_lfun[[3]],
#             tm_lfun[[4]],
#             tm_lfun[[5]],
#             tm_lfun[[6]],
#             tm_lfun[[7]],
#             ncol = 7) -> tm_lfun_all
tm_test_all
```



```{r}
tmap::tmap_save(tm = tm_test_all,
                filename = "tm_test.svg",
                #width = 500, 
                #height = 100,
                dpi = 400)
  
  
```


formatFunctions(layer.1 = c(fun = "linearFun",
                            a = -1.537881,
                            b = 0.5390189),
                layer.2 = c(fun = "linearFun",
                            a = vs.rnd$details$parameters$layer.2$args[["a"]],
                            b = vs.rnd$details$parameters$layer.2$args[["b"]])) %>%
  generateSpFromFun(raster.stack = Xs,
                  parameters = .,
                  rescale = FALSE, #rescale Y
                  rescale.each.response = FALSE, # rescale X
                  formula = NULL, #편반응결합에 쓰인 공식 
                  species.type = "additive", #각 변수에서 얻은 점수를 더함
                  plot = TRUE) -> testvs


개체군 밀도가 환경 반응 함수에 영향을 주는 종의 경우,
개체군 밀도를 반영한 모형이 그렇지 않은 모형보다 
더 정확한 예측력과 해석을 보인다

```{r}
set.seed(1)
vs.test.resc %>%
 map(function(x){
  convertToPA(x, 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = TRUE,
                    replacement = TRUE,
                    n = 1000,
                    sample.prevalence = 0.5,
                    #bias = "manual",
                    #weights = x$suitab.raster,
                    type = "presence-absence")}) -> PA
PA.KDE <- Reduce(function(x, y) replicate(y, x, F), rev(c(length(vs.test.resc),10)), NULL)
for(i in 1:length(vs.test.resc)){
for(j in 1:10){
  set.seed(j)
  convertToPA(vs.test.resc[[j]], 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = TRUE,
                    replacement = TRUE,
                    n = 1000,
                    sample.prevalence = 0.5,
                    #bias = "manual",
                    #weights = x$suitab.raster,
                    type = "presence-absence") -> PA.KDE[[i]][[j]]}}
presence.KDE <- list()
for(i in 1:length(PA.KDE)){
  PA.KDE[[i]] %>% 
  map(function(x){x$sample.points %>%
  filter(Real == 1)}) -> t
  map_dfr(t, rbind) -> presence.KDE[[i]]}
```



```{r}
set.seed(1)
vs.test %>%
 map(function(x){
  convertToPA(x, 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = TRUE,
                    replacement = TRUE,
                    n = 1000,
                    sample.prevalence = 0.5,
                    bias = "manual",
                    weights = x$suitab.raster,
                    type = "presence-absence")}) -> PA
PA[[1]]
```


```{r}
PA %>% 
  map(function(x){x$sample.points %>%
  filter(Real == 1)}) -> presence
PA %>% 
  map(function(x){x$sample.points %>%
  filter(Real == 0)}) -> absence
## test
set.seed(2)
vs.test.resc %>%
 map(function(x){
  convertToPA(x, 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = TRUE,
                    replacement = TRUE,
                    n = 1000,
                    sample.prevalence = 0.5,
                    #bias = "manual",
                    #weights = x$suitab.raster,
                    type = "presence-absence")}) -> PA.test
PA.test %>% 
  map(function(x){x$sample.points %>%
  filter(Real == 1)}) -> presence.test
PA.test %>% 
  map(function(x){x$sample.points %>%
  filter(Real == 0)}) -> absence.test
presence %>% 
  map(function(x){select(x, c("x", "y")) %>% 
      sf::st_as_sf(coords = c("x", "y"))}) -> sf.presence
presence %>%
  map(function(x){
  select(x, c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 1000),
                    yrange = c(0, 1000)))} %>%
  {density.ppp(x = .,
               edge = FALSE,
          kernel = "gaussian",
          sigma = 30,
          dimyx = c(1000,1000),
          eps = c(1,1))} %>%
  raster()}) -> KDE.presence
presence.KDE %>%
  map(function(x){
  select(x, c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 1000),
                    yrange = c(0, 1000)))} %>%
  {density.ppp(x = .,
               edge = FALSE,
          kernel = "gaussian",
          sigma = 10,
          dimyx = c(1000,1000),
          eps = c(1,1))} %>%
  raster()}) -> KDE.presence5k
KDE.presence5k <- KDE.presence5k[[1]] #yabal
```


```{r}
map(KDE.presence, function(x){x * Xs[[1]]}) -> KDExXs1
par(mfrow = c(2,7))
for(i in 1:7){
plot(KDExXs1[[i]])}
for(i in 1:7){
plot(vs.lfun[[i]]$suitab.raster)}
```

```{r}
# Xs1, Xs2, Xpop
pmap(list(presence, vs.lfun), function(y, z){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, z$suitab.raster),
                    p = y[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.Xpop
pmap(list(presence.test, absence.test, vs.lfun), function(y, z, xx){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, xx$suitab.raster),
                    p = y[,c("x", "y")],
                    a = z[,c("x", "y")])}) -> TEST.Xpop
# Xs1, Xs2, XpopxXs1
pmap(list(presence, vs.lfun), function(y, z){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, (z$suitab.raster * Xs[[1]])),
                    p = y[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.XpopxXs1
pmap(list(presence.test, absence.test, vs.lfun), function(y, z, xx){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, (xx$suitab.raster * Xs[[1]])),
                    p = y[,c("x", "y")],
                    a = z[,c("x", "y")])}) -> TEST.XpopxXs1
# Xs1, Xs2, KDE, KDExXS1
pmap(list(KDE.presence, presence, KDExXs1), function(x, y, z){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, x, z),
                    p = y[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.KDExXs1
pmap(list(KDE.presence, presence.test, absence.test, KDExXs1), function(x, y, z, xx){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, x, xx),
                    p = y[,c("x", "y")],
                    a = z[,c("x", "y")])}) -> TEST.KDExXs1
# Xs1, Xs2, KDExXS1
pmap(list(presence, KDExXs1), function(x, y){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, y),
                    p = x[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.xXs1
pmap(list(presence.test, absence.test, KDExXs1), function(x, y, z){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, z),
                    p = x[,c("x", "y")],
                    a = y[,c("x", "y")])}) -> TEST.xXs1
# Xs1, Xs2, KDE
map(presence.KDE, function(y){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, KDE.presence5k),
                    p = y[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.KDE
map2(presence.test, absence.test, function(y, z){
SDMtune::prepareSWD(species = "VS_KDE",
                    env = stack(Xs, KDE.presence5k),
                    p = y[,c("x", "y")],
                    a = z[,c("x", "y")])}) -> TEST.KDE
# Xs1, Xs2
map(presence, function(x){SDMtune::prepareSWD(species = "VS_dft",
                    env = Xs,
                    p = x[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.dft
map2(presence.test, absence.test, function(x, y){
SDMtune::prepareSWD(species = "VS_dft_test",
                    env = Xs,
                    p = x[,c("x", "y")],
                    a = y[,c("x", "y")])}) -> TEST.dft
# Xs1, Xs2, Xclim
map2(presence, Pred.MX.dft, function(x, Pred){SDMtune::prepareSWD(species = "VS_clim",
                    env = stack(Xs, Pred),
                    p = x[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000))}) -> SWD.clim
pmap(list(presence.test, absence.test, Pred.MX.dft), function(x, y, Pred){
SDMtune::prepareSWD(species = "VS_dft_test",
                    env = stack(Xs, Pred),
                    p = x[,c("x", "y")],
                    a = y[,c("x", "y")])}) -> TEST.clim
SWD.Xpop %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.Xpop
SWD.XpopxXs1 %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.XpopxXs1
SWD.KDExXs1 %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.KDExXs1
SWD.xXs1 %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.xXs1
SWD.KDE %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.KDE
SWD.dft %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.dft
SWD.clim %>% 
  map(function(x){
SDMtune::train(method = "Maxent",
               fc = "l",
               data = x)}) -> MX.clim
```

```{r}
SDMtune::plotResponse(model = MX.dft[[1]],
                      var = "layer.1")
SDMtune::plotResponse(model = MX.dft[[2]],
                      var = "layer.2")
```
## resid
```{r}
## Xpop
pmap(list(MX.Xpop, vs.lfun),
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y$suitab.raster))}) -> Pred.MX.Xpop
map2(vs.lfun, Pred.MX.Xpop, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.Xpop
## XpopxXs1
pmap(list(MX.XpopxXs1, vs.lfun),
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y$suitab.raster))}) -> Pred.MX.XpopxXs1
map2(vs.lfun, Pred.MX.XpopxXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.XpopxXs1
##
pmap(list(MX.KDExXs1, KDE.presence, KDExXs1),
     function(x, y, z){SDMtune::predict(x,
                 stack(Xs, y, z))}) -> Pred.MX.KDExXs1
map2(vs.lfun, Pred.MX.KDExXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.KDExXs1
map2(MX.xXs1, KDExXs1,
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y))}) -> Pred.MX.xXs1
map2(vs.lfun, Pred.MX.xXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.xXs1
map(MX.KDE, 
     function(x){SDMtune::predict(x,
                 stack(Xs, KDE.presence5k))}) -> Pred.MX.KDE
map2(vs.test.resc, Pred.MX.KDE, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.KDE
map(MX.dft,
     function(x){SDMtune::predict(x, Xs)}) -> Pred.MX.dft
map2(vs.test.resc, Pred.MX.dft, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.dft
map2(MX.clim, Pred.MX.dft,
     function(x, y){SDMtune::predict(x, stack(Xs, y))}) -> Pred.MX.clim
map2(vs.test.resc, Pred.MX.clim, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.clim
```

align to dft
```{r}
map2(resid.MX.dft, resid.MX.KDE, function(x, y){abs(x) - abs(y)}) -> align.KDE
align.KDE
```





```{r}
data.frame(Xclim = as.vector(rescale(vs.rnd$suitab.raster)),
Xpop = as.vector(vs.test.resc[[20]]$suitab.raster),
Xmclim = as.vector(Pred.MX.dft[[20]])) %>%
  pivot_longer(cols = everything(),
               names_to = "raster",
               values_to = "value") %>%
ggplot(aes(x = value, y = raster, fill = raster)) +
  geom_density_ridges(scale = 2, alpha = .3) +
  #scale_fill_manual(values = c("#666666", "#FF0000")) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme(axis.text = element_text(size = 40)) +
  labs(title = "TEST",
           y = "Possible habitat status",
           x = "출현 확률/서식처 적합도",
           size = 20) +
  theme_ridges(grid = FALSE) -> ridge
```

```{r}
ggsave("ridge.svg",
  ridge, width = 36, height = 15, units = "cm", dpi = 400, limitsize = F) 
```


```{r}
data.frame(#"-10" = resid.MX.dft[[1]],
           "n9" = resid.MX.dft[[2]],
           "n8" = resid.MX.dft[[3]],
           "n7" = resid.MX.dft[[4]],
           "n6" = resid.MX.dft[[5]],
           "n5" = resid.MX.dft[[6]],
           "n4" = resid.MX.dft[[7]],
           "n3" = resid.MX.dft[[8]],
           "n2" = resid.MX.dft[[9]],
           "n1" = resid.MX.dft[[10]],
           "p0" = resid.MX.dft[[11]],  
           "p1" = resid.MX.dft[[12]],
           "p2" = resid.MX.dft[[13]],
           "p3" = resid.MX.dft[[14]],
           "p4" = resid.MX.dft[[15]],
           "p5" = resid.MX.dft[[16]],
           "p6" = resid.MX.dft[[17]],
           "p7" = resid.MX.dft[[18]],
           "p8" = resid.MX.dft[[19]],
           "p9" = resid.MX.dft[[20]]) %>%
  pivot_longer(cols = everything(),
               names_to = "pop.effect",
               values_to = "value") -> df.ridge.resid
df.ridge.resid$pop.effect <-  factor(df.ridge.resid$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9"))
df.ridge.resid %>%
  ggplot(aes(x = value, y = pop.effect, fill = pop.effect)) +
  geom_density_ridges(scale = 5, alpha = .3) +
  #gghighlight(pop.effect == "X0") +
  #scale_fill_manual(values = c("grey80", "grey80", "grey80", "grey80", "grey80",
  #                             "grey80", "grey80", "grey80", "grey80", "#red",
  #                             "grey80", "grey80", "grey80", "grey80", "grey80",
  #                             "grey80", ,"grey80" ,"grey80" ,"grey80", "grey80")) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme(axis.text = element_text(size = 40)) +
  labs(title = "TEST",
           y = "Density",
           x = "Population effect size",
           size = 20) +
  theme_ridges(grid = FALSE) -> ridge.resid
```

```{r}
ggsave("ridge.resid.svg",
  ridge.resid, width = 36, height = 35, units = "cm", dpi = 400, limitsize = F) 
```

```{r}
data.frame(
  rmse.dft = map2_dbl(vs.test.resc, Pred.MX.dft, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.KDE = map2_dbl(vs.test.resc, Pred.MX.KDE, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.clim = map2_dbl(vs.test.resc, Pred.MX.clim, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
auc.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.clim = map2_dbl(MX.clim, TEST.clim, function(x,y){SDMtune::auc(model = x, test = y)}),
pop.effect = c("n10", names.pop.effect)) -> df.eval
df.eval
```

```{r}
df.eval %>%
  select(c("auc.dft", "auc.KDE", "auc.clim", "pop.effect")) %>%
  pivot_longer(cols = !"pop.effect",
               names_to = "eval", 
               values_to = "value") -> df.eval.auc
df.eval.auc$pop.effect <- factor(df.eval.auc$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9",
           "n10"))
df.eval.auc %>%
group_by(eval) %>%
  ggplot(aes(pop.effect, value, colour = eval)) +
  geom_point(aes(size = 5, alpha = 0.8)) +
  theme(axis.text = element_text(size = 40)) +
  theme_light() +
  labs(
           y = "AUC",
           x = "Population effect size",
           size = 20) -> plot.auc
df.eval %>%
  select(c("rmse.dft", "rmse.KDE", "rmse.clim", "pop.effect")) %>%
  pivot_longer(cols = !"pop.effect",
               names_to = "eval", 
               values_to = "value")  -> df.eval.rmse
df.eval.rmse$pop.effect <- factor(df.eval.rmse$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9",
           "n10"))
df.eval.rmse %>%
  group_by(eval) %>%
  ggplot(aes(pop.effect, value, colour = eval, alpha = 0.8)) +
  geom_point(aes(size = 5)) +
  theme(axis.text = element_text(size = 40)) +
  theme_light() +
  labs(
           y = "RMSE",
           x = "Population effect size",
           size = 20) -> plot.rmse
```

```{r}
ggsave("plot.auc.svg",
    plot.auc,
    width = 25,
    height = 15, 
    units = "cm", dpi = 400, limitsize = F) 
ggsave("plot.rmse.svg",
    plot.rmse,
    width = 25,
    height = 15, 
    units = "cm", dpi = 400, limitsize = F) 
```


```{r}
rbind(
as.data.frame(resid.MX.dft,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "dft", .after = "apop"),
as.data.frame(resid.MX.KDE,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "KDE", .after = "apop")) %>%
  ggplot(aes(interpolation, value)) +
  geom_violin()
```
```{r}
rbind(
as.data.frame(resid.MX.dft,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "dft", .after = "apop"),
as.data.frame(resid.MX.KDE,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "KDE", .after = "apop")) %>%
  ggplot(aes(apop, value, fill = interpolation)) +
  geom_violin()
```
```{r}
data.frame(
  rmse.Xpop = map2_dbl(vs.lfun, Pred.MX.Xpop, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.XpopxXs1 = map2_dbl(vs.lfun, Pred.MX.XpopxXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.dft = map2_dbl(vs.lfun, Pred.MX.dft, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.KDE = map2_dbl(vs.lfun, Pred.MX.KDE, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.KDExXs1 = map2_dbl(vs.lfun, Pred.MX.KDExXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.xXs1 = map2_dbl(vs.lfun, Pred.MX.xXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.dft = map2_dbl(vs.lfun, Pred.MX.dft, function(x, y){
  Metrics::mae(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
mae.KDE = map2_dbl(vs.lfun, Pred.MX.KDE, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.KDExXs1 = map2_dbl(vs.lfun, Pred.MX.KDExXs1, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.xXs1 = map2_dbl(vs.lfun, Pred.MX.xXs1, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
auc.Xpop = map2_dbl(MX.Xpop, TEST.Xpop, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDExXs1 = map2_dbl(MX.KDExXs1, TEST.KDExXs1, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.xXs1 = map2_dbl(MX.xXs1, TEST.xXs1, function(x,y){SDMtune::auc(model = x, test = y)}),
tss.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.KDExXs1, TEST.KDExXs1, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.xXs1, TEST.xXs1, function(x,y){SDMtune::tss(model = x, test = y)}),
prg.dft = map2(MX.dft, TEST.dft, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
                                #neg_scores = SDMtune::predict(x,
                                #                              y)[y@pa == 0])}) 
prg.KDE = map2(MX.KDE, TEST.KDE, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
prg.KDExXs1 = map2(MX.KDExXs1, TEST.KDExXs1, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
prg.xXs1 = map2(MX.xXs1, TEST.xXs1, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg)) -> df.eval
rbind(
  {dplyr::select(df.eval, ends_with("KDE")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "KDE")},
  {dplyr::select(df.eval, ends_with("dft")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
    mutate(interpolation = "dft")},
  {dplyr::select(df.eval, ends_with("KDExXs1")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "KDExXs1")},
  {dplyr::select(df.eval,  ends_with("xXs1") & !contains("KDE")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "xXs1")},
  {dplyr::select(df.eval,  ends_with("xXs1") & contains("Xpop")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "XpopxXs1")},
  {dplyr::select(df.eval,  ends_with("Xpop")) %>% 
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "Xpop")}
  ) %>%
  ggplot(aes(loss, value, colour = interpolation, size = 10)) +
  geom_point() +
  labs(title = "Model evaluation metrics",
           y = "Value",
           x = "Evaluation metrics",
           size = 15) +
      theme_light() +
      theme(axis.text = element_text(size = 14),
            legend.position = "bottom", legend.direction = "horizontal")-> plot.eval
plot.eval
ggsave(plot = plot.eval, filename = "plot.eval.svg", width = 480, height = 120, units = "mm", dpi = 400, limitsize = FALSE)
```



```{r}
data.frame(KDE = align.KDE) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "interpolation",
               values_to = "value") %>%
  ggplot(aes(interpolation, value)) +
  geom_violin()
```





```{r}
rbind(vs.rnd$details$parameters[[1]]$args, vs.rnd$details$parameters[[2]]$args)
```
```{r}
rbind(vs.lfun[[4]]$details$parameters[[1]]$args, vs.lfun[[4]]$details$parameters[[2]]$args)
```




```{r}
map_dbl(vs.lfun, function(vs.l){
cor(as.vector(vs.rnd$suitab.raster - vs.l$suitab.raster), as.vector(Xs$layer.2))})
cor(as.vector(vs.lfun[[5]]$suitab.raster - vs.rnd$suitab.raster), as.vector(Xs$layer.2))
```







```{r}
set.seed(1)
vs.rnd %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.1) %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 1000,
                    type = "presence-absence") -> PA
PA$sample.points %>%
  filter(Real == 1) -> presence
presence %>% select(c("x", "y")) %>% sf::st_as_sf(coords = c("x", "y")#,
                                                    ) -> sf.presence
presence %>%
  select(c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 100),
                    yrange = c(0, 100)))} %>%
  {density.ppp(x = .,
               edge = FALSE,
          kernel = "gaussian",
          sigma = 7,
          dimyx = c(100,100),
          eps = c(1,1))} %>%
  raster() -> KDE.presence
#KS.b.1 %>% {raster(x = .$v,
##                   xmn = 0, 
##                   ymn = 0,
#                   xmx = 100,
#                   ymx = 100)} -> KS.b.1
```

```{r}
vs.rnd %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) -> PA
PA %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 6,
                    sample.prevalence = 0.5,
                    replacement = TRUE,
                    type = "presence-absence") -> occ
#3^(2:9)
#seq(10, 1000, by = 100)
purrr::accumulate(append(list(occ), seq(10, 100, by = 10)), function(occs, n){
occs$sample.points[occs$sample.points$Real == 1,c("x", "y")] %>%
 st_as_sf(coords = c("x", "y")) %>%
 st_buffer(., 
           dist = 5) %>%
  as_Spatial() %>%
  sampleOccurrences(PA,
                    bias = "polygon", 
                    bias.area = .,
                    extract.probability = TRUE,
                    n = n,
                    bias.strength = 500,
                    sample.prevalence = 0.5,
                    replacement = TRUE,
                    type = "presence-absence")}) -> bias.occ
```

```{r}
map(bias.occ, function(occs){
occs$sample.points %>%
  filter(Real == 1)}) -> presence
#presence %>% select(c("x", "y")) %>% sf::st_as_sf(coords = c("x", "y")#,
#                                                    ) -> sf.presence
presence %>%
map(function(presence){
  presence %>%
  select(c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 100),
                    yrange = c(0, 100)))} %>%
  Kest()}) -> L.presence
map(L.presence, plot)
```


```{r warning=FALSE}
tmap_arrange(
  tm_shape(KDE.presence) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom")),
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom")))
```
 

```{r}
tm_shape(Xs) +
  tm_raster()
```

[min=0; max=1] : linearFun   (a=-0.232323232323232; b=0.132171321713217)

```{r}
plotResponse(vs.rnd)
```


```{r}
SDMtune::prepareSWD(species = "VS1",
                    env = stack(Xs, KDE.presence),
                    p = presence[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000)) -> SWD
SDMtune::train(method = "Maxent",
               data = SWD) -> MX
```

```{r}
SDMtune::plotResponse(model = MX,
                      var = "layer.1")
SDMtune::plotResponse(model = MX,
                      var = "layer.2")
```

```{r}
SDMtune::predict(MX, stack(Xs, KDE.presence)) -> PRED.MX
```


```{r}
tmap_arrange(
  tm_shape(PRED.MX) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
    tm_layout(legend.position = c("right", "bottom")), # PRED map
  tm_shape(z) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() + 
  tm_layout(legend.position = c("right", "bottom")), # KDE map
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom"))) # HS map
```




## 

```{r}
SDMtune::prepareSWD(species = "VS1",
                    env = stack(Xs),
                    p = presence[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000)) -> SWD.Xs
SDMtune::train(method = "Maxent",
               data = SWD.Xs,
               fc = c("l")) -> MX.Xs.L
SDMtune::train(method = "Maxent",
               data = SWD.Xs) -> MX.Xs.LQPH
```

```{r}
SDMtune::plotResponse(model = MX.Xs.L,
                      var = "layer")
```


```{r}
SDMtune::predict(MX.Xs.L, stack(Xs)) -> PRED.MX.Xs.L
```

```{r}
SDMtune::predict(MX.Xs.LQPH, stack(Xs)) -> PRED.MX.Xs.LQPH
```

```{r}
tmap_arrange(
  tm_shape(PRED.MX.Xs) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
    tm_layout(legend.position = c("right", "bottom")), # PRED map
  tm_shape(KDE.presence) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() + 
  tm_layout(legend.position = c("right", "bottom")), # KDE map
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom"))) # HS map
```

```{r}
(vs.rnd$suitab.raster - PRED.MX.Xs.L) %>% as.vector() -> resid.Xs.L
(vs.rnd$suitab.raster - PRED.MX.Xs.LQPH) %>% as.vector() -> resid.Xs.LQPH
data.frame(XL.L = resid.Xs.L,
           Xs.LQPH = resid.Xs.LQPH) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "fc",
               values_to = "value") %>%
  ggplot(aes(fc, value)) +
  geom_violin()
```

```{r}
((10000*KDE.presence*Xs) + 0.132171321713217) -> z
```


set.seed(1)
a[[1]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 600,
                    type = "presence-absence") -> b.1.1


b.1$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.1

sf.b.1 %>%  
  st_buffer(5) -> buf.b.1


tm_shape(a[[1]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.1) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.1) +
  tm_dots() +
tm_layout(legend.outside = TRUE)-> tm.b1
tm.b1















a[[2]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "polygon",
                    bias.area = as_Spatial(buf.b.1),
                    bias.strength = 5,
                    extract.probability = T,
                    n = 600,
                    type = "presence-absence") -> b.2

b.2$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.2

sf.b.2 %>%  
  st_buffer(5) -> buf.b.2

tm_shape(a[[2]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.2) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.2) +
  tm_dots() +
tm_layout(legend.outside = TRUE)-> tm.b2
tm.b2



a[[3]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "polygon",
                    bias.area = as_Spatial(buf.b.2),
                    bias.strength = 5,
                    extract.probability = T,
                    n = 900,
                    type = "presence-absence") -> b.3

b.3$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.3

sf.b.3 %>%  
  st_buffer(5) -> buf.b.3


tm_shape(a[[3]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.3) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.3) +
  tm_dots() +
tm_layout(legend.outside = TRUE) -> tm.b3
tm.b3

tmap_arrange(tm.b1, tm.b2, tm.b3)

첫번째 지도(tm.1)는 출현 자료의 공간구조가 서식처 적합도에 영향을 못주는 형태
두번째 지도(tm.2)는 출현 자료의 공간구조가 반응함수를 수정했고(사실 내가 수정함)
그 반응함수에 따라 서식처 적합도가 재계산되었으며(사실 새로 종 만듬)
해당 서식처 적합도 내에서 출현 자료가 재수집되나 기존 출현자료인근에서 더 자주 수집되도록 설정하였음.


a[[4]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "manual",
                    weights = a[[4]]$suitab.raster,
                    extract.probability = T,
                    n = 1200,
                    type = "presence-absence") -> b.4

a[[5]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "manual",
                    weights = a[[5]]$suitab.raster,
                    extract.probability = T,
                    n = 1500,
                    type = "presence-absence") -> b.5



#  convertToPA(., 
#               PA.method = "probability",
#               prob.method = "linear",
#               species.prevalence = 0.5) %>%
#  sampleOccurrences(.,
#                    extract.probability = T,
#                    n = 600,
#                    type = "presence-absence")}) -> Occs

#map(a, plotResponse)
list(b.1, b.2, b.3) %>% map(function(x){st_as_sf(x$sample.points, coords = c("x", "y"))}) %>%
  map(function(x){plot(x["Real"])})




map(a, function(x){plot(x$suitab.raster)})-> c