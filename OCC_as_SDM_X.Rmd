---
title: "Title"
description: |
  Population affect Response function, SDM, Occurrence
author:
  - name: Cheongok Jeon 
    url: https://github.com/lophital
    affiliation: Seoul National University, Korea
    affiliation_url: https://geog.snu.ac.kr/
    orcid_id: 0000-0002-9950-6794
  - name: Daehyun Kim
    affiliation: Seoul National University, Korea
    affiliation_url: https://geog.snu.ac.kr/
    orcid_id: 0000-0001-9239-5895
twitter: 
  site: "@lophital"
  creator: "@lophital"
journal: 
  title: "Ecography"
  pasge: "1-27"
  # issn: 2490-1752
  # publisher: ESA
# volume: 44
# issue: 4
doi: "10.1002/ecm.1486"
date: "2023-1-1"
bibliography: references.bib
bib-humanities: true
output: 
  distill::distill_article:
    toc: true
    toc_depth: '2'
    theme: theme.css
creative_commons: CC BY
header-includes: 
  \usepackage{caption}
  \renewcommand{\figurename}{Fig.} 
  \renewcommand{\thefigure}{S\arabic{figure}} 
  \renewcommand{\thetable}{S\arabic{table}}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)
```

```{r here}
here::i_am("OCC_as_SDM_X.Rmd") # location of current script within the TURKEY project is declared
library(here) # load here pacakge 
```


```{r}
data_path <- here("data") 
data_path
```

# Pre
## load things
```{r}
library(tidyverse)
library(sf)
library(tmap)
library(virtualspecies)
library(raster)
library(spatstat)
library(SDMtune)
library(precrec)
library(Metrics)
library(prg)
library(rasterVis)
```



## conflict
```{r}
conflicted::conflict_prefer(name = "select", winner = "dplyr")
conflicted::conflict_prefer(name = "filter", winner = "dplyr")
#conflicted::conflict_prefer(name = "stack", winner = "raster")
#conflicted::conflict_prefer(name = "stack", winner = "utils")
conflicted::conflict_prefer(name = "auc", winner = "SDMtune")
conflicted::conflict_prefer(name = "predict", winner = "SDMtune")
```


# 1. Intro
## 1.1 env.var - bioclimate 
```{r}
list.files(path = paste(system.file(package = "dismo"),
                        "/ex", sep = ''),
           pattern = "grd",
           full.names = TRUE) %>%
  str_subset("biome", negate = TRUE) %>%
  .[c(1,5,6,7,8,2,3,4)] %>%
  raster::stack() -> bioclim
bioclim
```
Bioclimate variable is stacked raster 

Fix names and order


```{r}
list.files(path = data_path, 
           full.names = TRUE) %>%
  raster::stack() -> bioclim
bioclim
```


```{r}

names(bioclim) <- c("bio01", "bio05", "bio06", "bio07", "bio08", "bio12", "bio16", "bio17")
Xs <- bioclim
Xs.name <- names(Xs)
Xs
```


```{r}
# standardization
for(i in 1:nlayers(Xs)){
(Xs[[i]] - cellStats(Xs[[1]], mean)) / cellStats(Xs[[i]], sd) -> Xs[[i]]
}


my.rescale <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = raster::minValue(x)
  if(is.null(x.max)) x.max = raster::maxValue(x)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}

my.rescale.vc <- function(x, x.min = NULL, x.max = NULL, new.min = 0, new.max = 1) {
  if(is.null(x.min)) x.min = base::min(x, na.rm = TRUE)
  if(is.null(x.max)) x.max = base::max(x, na.rm = TRUE)
  new.min + (x - x.min) * ((new.max - new.min) / (x.max - x.min))
}

# normalization
for(i in 1:nlayers(Xs)){
  my.rescale(Xs[[i]]) -> Xs[[i]]
}

Xs

```
standard, norm so that paramters(apop, Mu, etc) can effect under certain range(0~1, apop.range, mu.range etc)


```{r}

rasterVis::levelplot(Xs, par.settings = viridisTheme(), contour = FALSE)
#png(filename = "test.png",res = 300) if saving is needed
#dev.off()
```

Create raster blank, raster fill.
raster fill indiacate which cell have value or not

```{r}
is.na(Xs[[1]]) -> raster.blank
!is.na(Xs[[1]]) -> raster.fill

which(as.vector(raster.fill)) -> vc.filled # cell IDs to fill in in after MC Equation fitting.

as.vector(raster.blank) %>% length() # around 35712
```


기존의 연구 방식은 환경 변수 Xs에 의해 Xpop 혹은 HS가 결정된다고 보고 
알려진 환경 변수 래스터에 특정한 함수(선형이나 정규분포) 따위를 적용해 
최종 서식처 적합도(Xpop = Yhs)를 계산했다.

하지만 본 연구에서 제기하는 상황(Xpop이 방정식 좌우항에 포함되는 상황)에서는 식의 정리(= Xpop에 대한 식으로 정리)가 어렵다(수학적으로 불가능하다고 여기는 중). 특히 정규분포 식의 복잡한 공식 때문에 방정식 조합을 만족하는 Xpop을 추정하는 것은 무척 어렵다. 
대신, 접근법을 달리하여
방정식에 = 을 사용하지 않고 <= 같은 근사치를 구하는 것으로 접근을 바꾸었다.
따라서, 

X1에 따른 Xpop을 구하는 방법은 다음과 같다.
1. Xs 를 무작위로 선정한다.
2. apop_n, sigma_n, mu 등의 계수와 상수들을 선정한다.
3. 방정식에 최대한 근접하는 Xpop을 추정한다.

3번째 단계를 위해서 몬테카를로 방식을 도입한다.
몬테카를로 방식은 다음과 같다.
1. 샘플수를 선정
2. 구하고자 하는 Xpop의 범위를 선정
3. 정확도를 선정(acc.lim)
4. 정확도를 점차 높여가며 최대로 정확한(= 0에 가까운) Xpop의 집합을 추림
5. 남은 Xpop의 집합의 평균을 Xpop으로 선정


개체군 효과의 영향을 받은 변수는 prime,
개체군 효과의 영향을 받지 않는 변수는 dprime으로 구분한다.

에러:
addTaskCallback(function(...) {set.seed(123);TRUE})


# Test 2. Foreach level


```{r Testing foreach to raster level-range set}
## param range
mu.range <- seq(0.1, 0.9, by = 0.1)
a.range <- seq(0.1, 0.9, by = 0.1)
b.range <- seq(0.1, 0.9, by = 0.1)
sigma.range <- seq(0.1, 0.9, by = 0.1)
apop.range <- seq(0.1, 0.9, by = 0.1)
e.variable.n.range <- 2:nlayers(Xs) # 몇개의 환경 변수를 뽑을 것인가?
e.variable.name.range <- 1:nlayers(Xs) # 어떤 환경 변수를 뽑을 것인가?

## Formulas
forms.gaus.prime <- function(Xs){ # prime
  ((1/sqrt(2*pi)*(Xpop*apop.prime + sigma.dprime))*exp(1)^(-(Xs[i]-mu)^2/2*((Xpop*apop.prime + sigma.dprime))^2)) -> vc
  idx.over <- vc > 1
  idx.lower <- vc < 0
  vc[idx.over] <- 1
  vc[idx.lower] <- 0
  return(vc)
}


forms.gaus <- function(Xs){
  ((1/sqrt(2*pi)*sigma)*exp(1)^(-(Xs[i]-mu)^2/2*(sigma)^2)) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms.linear.prime <- function(Xs){ # prime
  ((Xpop*apop.prime + apop.dprime)*Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

# ifelse is slow.
# vectorization :)

forms.linear <- function(Xs){
  (a *Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms <- list(forms.gaus, forms.gaus.prime, forms.linear, forms.linear.prime)


pop.forms <- list(forms.gaus.prime, forms.linear.prime)
no.pop.forms <- list(forms.gaus, forms.linear)
  
  
acc.lim <- rev(seq(from = 0.0000005, to = 0.0001, by = 0.0000005))
r.vector <- vector()
```

## parallel 
```{r}
library(parallel) #parallel computing
library(foreach)
library(doParallel)

cores <- 60
cluster <- parallel::makeCluster(spec = cores, outfile="")
doParallel::registerDoParallel(cl = cluster)
```


시딩을 먼저 하고.
채워진 모든 셀 i에 대하여

시딩에 따른 계수
시딩에 따른 공식
을 적용해 좌변을 만든다. -> Test

좌변 - xpop이 0.1보다 적은지 테스트 하는 과정(while)
## foreach MC




```{r Testing foreach to raster level-functional}
set.seed(seed)
Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))
acc.lim <- rev(seq(from = 0.0000005, to = 0.0005, by = 0.0000005))

##############
## FOR EACH ##
##############

r.vector.test.foreach <- list()
results <- list()
for(seed in 1:1000){
set.seed(seed)
## parameter sampling
mu <- sample(mu.range, 1)
sigma <- sample(sigma.range, 1)
sigma.dprime <- sample(sigma.range, 1)
a <- sample(a.range, 1)
apop.prime <- sample(apop.range, 1)
apop.dprime <- sample(apop.range, 1)
b <- sample(b.range, 1)

param <- c(mu, sigma, sigma.dprime, a, apop.prime, apop.dprime, b)

## variable selection
set.seed(seed)
Xs.choosen <- Xs[[sort(sample(e.variable.name.range, sample(e.variable.n.range, 1)))]]

## forms choosen
set.seed(seed)
forms.choosen <- sample(forms, nlayers(Xs.choosen), replace = TRUE)  
  
    foreach(i = vc.filled, .packages = c("magrittr", "purrr", "raster")) %dopar% {

#Xpop <- runif(100000*nlayers(Xs.choosen), min = 0, max = nlayers(Xs.choosen))
#.GlobalEnv$Xpop <- Xpop
#.GlobalEnv$apop.prime <- apop.prime
#.GlobalEnv$sigma.dprime <- sigma.dprime
#.GlobalEnv$i <- vc.filled
#.GlobalEnv$mu <- mu
#.GlobalEnv$sigma <- sigma
#.GlobalEnv$a <- a
#.GlobalEnv$apop.dprime <- apop.dprime
#.GlobalEnv$b <- b
#.GlobalEnv$acc.lim <- acc.lim

## Formulas
forms.gaus.prime <- function(Xs){ # prime
  ((1/sqrt(2*pi)*(Xpop*apop.prime + sigma.dprime))*exp(1)^(-(Xs[i]-mu)^2/2*((Xpop*apop.prime + sigma.dprime))^2)) -> vc
  idx.over <- vc > 1
  idx.lower <- vc < 0
  vc[idx.over] <- 1
  vc[idx.lower] <- 0
  return(vc)
}


forms.gaus <- function(Xs){
  ((1/sqrt(2*pi)*sigma)*exp(1)^(-(Xs[i]-mu)^2/2*(sigma)^2)) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms.linear.prime <- function(Xs){ # prime
  ((Xpop*apop.prime + apop.dprime)*Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

# ifelse is slow.
# vectorization :)

forms.linear <- function(Xs){
  (a *Xs[i] + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
}

forms <- list(forms.gaus, forms.gaus.prime, forms.linear, forms.linear.prime)


set.seed(seed)
forms.choosen <- sample(forms, nlayers(Xs.choosen), replace = TRUE)

map2(forms.choosen, # which formula to apply
     map(as.list(Xs.choosen), function(x){list(Xs = x)}),  # supply choosen variables as list
     function(fn, args){exec(fn, !!!args)}) -> test.1
     as.data.frame(test.1) %>% 
     rowSums() -> test.2 # formula result 우변, 좌변은 Xpop
# abs(test-Xpop)은 좌변을 우변으로 옮겨서 계산하는 과정을 의미합니다.
# 이것이 0이면 방정식이지만 계산이 어렵고 근사치로도 충분하기 때문에 0에 최대한 근접하게 하는(= acc.lim을 0에 가깝게 늘려가면서!)
# Xpop을 추정하는 것이 목적입니다!
j <- 1
inequation <- abs(test.2 - Xpop) < 0.1
  while(length(Xpop[inequation]) > 4 && j == length(acc.lim)-1){ # 정확도의 조건은 최종 후보자가 4개 이하거나 acc.lim을 거의 끝(-1)까지 갔을 때
    j <- j+1
inequation <- abs(test.2 - Xpop) < acc.lim[j]
}
mean(Xpop[inequation])} -> r.vector
map_dbl(r.vector, rbind) -> r.vector.test.foreach[[seed]]

results[[seed]] <- tribble(~seed, ~vc, ~param, ~Xs.choosen, ~forms.choosen,
        seed, r.vector.test.foreach[[seed]], c(mu, sigma, sigma.dprime, a, apop.prime, apop.dprime, b), names(Xs.choosen), forms.choosen)
}

results %>% map_dfr(rbind) -> results

```

```{r}

results %>%
  mutate(rasters = map2(vc, list(raster.fill), function(vc, raster.fill){raster.fill[raster::values(raster.fill)] <- vc
                                                                          return(my.rescale(raster.fill))})
         ) -> results

results$rasters[21:30] %>% stack() %>% rasterVis::levelplot()
```
Map of Habitat Suitability


## 1.2 Virtual Species


```{r results='hide', message=FALSE}
set.seed(1)
my.rndsp <- function(Xs.choosen){
virtualspecies::generateRandomSp(raster.stack = Xs[[Xs.choosen]],
                                 approach = "response",
                                 rescale = FALSE,
                                 rescale.each.response = FALSE,
                                 convert.to.PA = FALSE,
                                 species.type = "additive",
                                 relations = c("linear"))} # just make any random sp as "default"
results %>%
  mutate(rnd = map(Xs.choosen, my.rndsp)) -> results # with choosen Xs, make random default virtual species

for(i in 1:length(results$rnd)){
results$rnd[[i]]$suitab.raster <- results$rasters[[i]]} # Replace it with our new "affected" raster ###########################


my.occ <- function(vs){
  convertToPA(vs, 
               PA.method = "probability", # Q. 
               prob.method = "linear", a = 1, b = 0) %>% # Habitat suitability turned out as Occurrence Prob(a = 1).
               #species.prevalence = 0.1) %>% # Prevalence? 
  sampleOccurrences(.,
                    extract.probability = TRUE,
                    replacement = TRUE,
                    n = 1000,
                    sample.prevalence = 0.5,
                    #bias = "manual",
                    #weights = x$suitab.raster,
                    type = "presence-absence")}

results$rasters %>% map_dbl(raster::maxValue) %>% is.na() %>% which() -> problematic #Some rasters have NA
results.test.less <- results[-problematic,]


results.test.less %>%
  mutate(PA_train = map(rnd , my.occ),
         presence_train = map(PA_train, function(PA_train){PA_train$sample.points %>% filter(Real == 1)}),
         absence_train = map(PA_train, function(PA_train){PA_train$sample.points %>% filter(Real == 0)}),
         PA_test = map(rnd , my.occ),
         presence_test = map(PA_test, function(PA_test){PA_test$sample.points %>% filter(Real == 1)}),
         absence_test = map(PA_test, function(PA_test){PA_test$sample.points %>% filter(Real == 0)})) -> results.test.less

#for(i in 447:nrow(results.test.less)){ ** SOME rasters show weird looking.
#my.occ(results.test.less$rnd[[i]])}

```

```{r}
bg10k <- dismo::randomPoints(Xs, 10000)
```



```{r}
results %>%
  mutate(mean = map_dbl(rasters, function(rasters){
    rasters[rasters == 0] <- NA
    cellStats(rasters, mean)}),
    b = map_dbl(param, function(param){param[7]}),
    apop.prime = map_dbl(param, function(param){param[5]}),
    n.Xs = map_dbl(Xs.choosen, length)) -> df
df %>%
  ggplot(aes(x = mean, y = b, color = apop.prime)) +
  geom_point()

```
it seems b regulate "how monotonous" the HS raster

```{r}
library(ggridges)

df %>%
  mutate(b = as.factor(b)) %>%
  ggplot(aes(x = mean, y = b)) +
  geom_density_ridges(position = position_dodge())
```

distinctive




# 2.Modelling

```{r}

results.test.less %>%
  mutate(SWD_train = pmap(list(seed, Xs.choosen, presence_train), function(seed, Xs.choosen, presence_train){
    SDMtune::prepareSWD(species = paste0(seed, "_VS"),
                    env = Xs[[Xs.choosen]],
                    p = presence_train[,c("x", "y")],
                    a = bg10k)})) -> test

problematic <- 
test$SWD_train %>% map_dbl(function(x){sum(x@pa == 1)}) < 100 

test <- test[-which(problematic),]


test %>%
  mutate(MX = map(SWD_train, function(SWD){
    SDMtune::train(method = "Maxent",
                     data = SWD,
                       fc = "lqpt")})
    ) -> test

test %>%
  mutate(pred = map2(MX, Xs.choosen, function(MX, Xs.choosen){
    SDMtune::predict(MX, Xs[[Xs.choosen]])})) -> test 
test %>%
  mutate(resid = map2(rasters, pred, function(rasters, pred){rasters - pred}),
         rmse = map2_dbl(rasters, pred, function(rasters, pred){Metrics::rmse(actual = as.vector(rasters[!is.na(pred)]),
                                                                          predicted =  na.omit(as.vector(pred)))}),
         apop.prime = map_dbl(param, function(param){param[5]}),
         b = map_dbl(param, function(param){param[7]})
         ) -> test #this was test.2

```

```{r}
name.param <- c("mu", "sigma", "sigma.dprime", "a", "apop.prime", "apop.dprime", "b")
```

 
 parameter used?
 
```{r}
test %>%
  mutate(forms.ifnot = forms.choosen) -> test_ifnot

    for(i in 1:length(test_ifnot$forms.ifnot)){
      for(j in 1:length(test_ifnot$forms.ifnot[[i]])){
        ifelse(test = identical(test_ifnot$forms.ifnot[[i]][[j]], forms[[1]]), 
           yes = test_ifnot$forms.ifnot[[i]][[j]] <- forms[[1]], 
           no = ifelse(test = identical(test_ifnot$forms.ifnot[[i]][[j]], forms[[2]]), 
                       yes = test_ifnot$forms.ifnot[[i]][[j]] <- forms[[1]], # if 2 prime, change to 1 
                       no = ifelse(test = identical(test_ifnot$forms.ifnot[[i]][[j]], forms[[3]]), 
                                   yes = test_ifnot$forms.ifnot[[i]][[j]] <- forms[[3]],
                                   no = ifelse(test = identical(test_ifnot$forms.ifnot[[i]][[j]], forms[[4]]), 
                                               yes = test_ifnot$forms.ifnot[[i]][[j]] <- forms[[3]] # if 4 prime, change to 3
                                               )
                                   )
                       )
           )
      }
      }
      
test_ifnot$forms.ifnot[[2]]
    

```
 





# 3. Discussion

## 3.1 SDM with bioclimate can predict population effect?
### 3.1.1 Prediction Residuals 

First, split result by params
cuz all results doesn't show any trend

예상되는 파라미터들

변수의 갯수

```{r}
test %>%
  mutate(mu = map_dbl(param, function(param){param[1]}),
         sigma = map_dbl(param, function(param){param[2]}),
         sigma.dprime = map_dbl(param, function(param){param[3]}),
         a = map_dbl(param, function(param){param[4]}),
         apop.dprime = map_dbl(param, function(param){param[6]}),
         apop.prime = map_dbl(param, function(param){param[5]}),
         b = map_dbl(param, function(param){param[7]})
         ) -> test

test %>%
  mutate(form_rate = round(map_dbl(forms.choosen, function(forms.choosen){my.TF_rate(forms.choosen %in% pop.forms)}), 2)) -> test


test %>%
  filter(form_rate > 0.4) %>%
  filter(sigma.dprime < 0.4) %>%
  filter(apop.dprime < 0.4) %>%
  filter(b < 0.4) %>%
  #mutate(apop.prime = as.factor(apop.prime)) %>%
  ggplot(aes(x = apop.prime, y = rmse, colour = b)) +
  geom_point() +
  scale_colour_viridis_b()
```



### 3.1.2 Residual SAC

### 3.1.3 Correlation
```{r}

Xs[[test_ifnot$Xs.choosen[[1]]]][[1]] %>% raster::calc(test_ifnot$forms.ifnot[[1]][[1]]) %>% plot()

```


### 3.1.3 Evaluating Metrics
#### AUC
#### TSS
#### Boyce


## 3.2 SDM with Bioclimate can interpret population effect?

### 3.2.1 Variable importance
```{r}
test %>%
  mutate(varimp = map(MX, SDMtune::maxentVarImp)) -> test
test$varimp[[2]]
test$param[[2]]
```





### 3.2.2 residuals from Response curve

```{r}

forms_no.i <- list(

function(Xs){
  ((1/sqrt(2*pi)*sigma)*exp(1)^(-(Xs-mu)^2/2*(sigma)^2)) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
},


function(Xs){ # prime
  ((1/sqrt(2*pi)*(Xpop*apop.prime + sigma.dprime))*exp(1)^(-(Xs-mu)^2/2*((Xpop*apop.prime + sigma.dprime))^2)) -> vc
  idx.over <- vc > 1
  idx.lower <- vc < 0
  vc[idx.over] <- 1
  vc[idx.lower] <- 0
  return(vc)
},

# ifelse is slow.
# vectorization :)

function(Xs){
  (a *Xs + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
},

function(Xs){ # prime
  ((Xpop*apop.prime + apop.dprime)*Xs + b) -> vc
  idx.over <- vc > 1
   idx.lower <- vc < 0
   vc[idx.over] <- 1
   vc[idx.lower] <- 0
   return(vc)
})

```



```{r}

test %>%
  mutate(var_code = map(forms.choosen, function(forms.choosen){match(forms.choosen, forms)})) -> test

test %>%
  mutate(fomrs_no.i = map(var_code, function(var_code){forms_no.i[var_code]})) -> test
  

mutate(varname = map(MX, function(MX){names(MX@data@data)})) %>%
  mutate(response = map2(MX, varname, function(MX, varname){
    SDMtune::plotResponse(MX, var = varname)})) -> test

SDMtune::plotResponse(test$MX[[1]], var = names(test$MX[[1]]@data@data)[1]) -> RR
respo_actual <- test$forms.choosen

RR_actual <-
ggplot(data.frame(x = c(0, 1)), aes(x = x)) +
  stat_function(fun = test$fomrs_no.i[[1]][[1]]) +
ggplot(RR$data, aes(x = x, y = y))
  
ggarrange(RR, RR_actual)


```


```{r}
test$forms.choosen[[1]]
```

```{r}
test$param[[1]]
```












```{r}
#test.2 will work same with test
test.2 %>%
  dplyr::select(c("apop.prime", "rmse")) %>%
  mutate(apop.prime = as.factor(apop.prime)) %>%
  ggplot(aes(x = apop.prime, y = rmse)) +
  geom_boxplot()
```

```{r}
test.2 %>%
  filter(b < 0.2) %>%
  filter(apop.prime < 3)
  dplyr::select(c("apop.prime", "rmse")) %>%
  mutate(apop.prime = as.factor(apop.prime)) %>%
  ggplot(aes(x = apop.prime, y = rmse)) +
  geom_boxplot()
```
```{r}
test.2 %>%
  filter(b < 0.2) %>% # sample of 136 vs
  dplyr::select(c("apop.prime", "rmse")) %>%
  mutate(apop.prime = as.factor(apop.prime)) %>%
  ggplot(aes(y = apop.prime, x = rmse)) +
  geom_density_ridges()
```

```{r}
data.frame(
actual = as.vector(test$rnd[[8]]$suitab.raster),
predict = as.vector(test$pred[[8]])) %>%
  na.omit() %>%
  ggplot(aes(x = actual, y = predict)) +
  geom_point() +
  geom_abline(aes(intercept = 0, slope = 1))


```

resid = actual - predict

resid > 0 means, actual > predict, underestimate

```{r}
test %>%
  mutate(OEUE_rate = map_dbl(resid, function(resid){
    resid.vc <- na.omit(as.vector(resid))
    resid.vc <- resid.vc[abs(resid.vc) > 0.1]
    length(resid.vc[resid.vc < 0]) / length(resid.vc) * 100 # 전체 중, overestimate 한 픽셀의 비율
  })) -> test

hist(test$OEUE_rate[test$OEUE_rate != Inf])

```



```{r}
test %>%
  mutate(mu = as.factor(map_dbl(param, function(param){param[1]}))) %>%
  dplyr::select(c("mu", "rmse")) %>%
  ggplot(aes(x = mu, y = rmse)) +
  geom_boxplot()
```
```{r}

my.TF_rate <- 
function(x){sum(x == TRUE)/length(x)}

test %>%
  mutate(form_rate = round(map_dbl(forms.choosen, function(forms.choosen){my.TF_rate(forms.choosen %in% pop.forms)}), 2),
         form_rate = as.factor(form_rate)) %>%
  dplyr::select(c("form_rate", "rmse")) %>%
  ggplot(aes(x = form_rate, y = rmse)) +
  geom_boxplot()
```



```{r}
data.frame(HS = as.vector(test.2$rnd[[985]]$suitab.raster),
           X2 = as.vector(Xs[[test.2$Xs.choosen[[985]]]][[1]])) %>%
  na.omit() %>%
  ggplot(aes(x = X2, y = HS)) +
  geom_point() 

```
```{r}

```




## resid
```{r}
## Xpop
pmap(list(MX.Xpop, vs.lfun),
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y$suitab.raster))}) -> Pred.MX.Xpop
map2(vs.lfun, Pred.MX.Xpop, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.Xpop
## XpopxXs1
pmap(list(MX.XpopxXs1, vs.lfun),
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y$suitab.raster))}) -> Pred.MX.XpopxXs1
map2(vs.lfun, Pred.MX.XpopxXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.XpopxXs1
##
pmap(list(MX.KDExXs1, KDE.presence, KDExXs1),
     function(x, y, z){SDMtune::predict(x,
                 stack(Xs, y, z))}) -> Pred.MX.KDExXs1
map2(vs.lfun, Pred.MX.KDExXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.KDExXs1
map2(MX.xXs1, KDExXs1,
     function(x, y){SDMtune::predict(x,
                 stack(Xs, y))}) -> Pred.MX.xXs1
map2(vs.lfun, Pred.MX.xXs1, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.xXs1
map(MX.KDE, 
     function(x){SDMtune::predict(x,
                 stack(Xs, KDE.presence5k))}) -> Pred.MX.KDE
map2(vs.test.resc, Pred.MX.KDE, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.KDE
map(MX.dft,
     function(x){SDMtune::predict(x, Xs)}) -> Pred.MX.dft
map2(vs.test.resc, Pred.MX.dft, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.dft
map2(MX.clim, Pred.MX.dft,
     function(x, y){SDMtune::predict(x, stack(Xs, y))}) -> Pred.MX.clim
map2(vs.test.resc, Pred.MX.clim, function(x, y){
  as.vector(x$suitab.raster - y)}) -> resid.MX.clim
```

align to dft
```{r}
map2(resid.MX.dft, resid.MX.KDE, function(x, y){abs(x) - abs(y)}) -> align.KDE
align.KDE
```





```{r}
data.frame(Xclim = as.vector(rescale(vs.rnd$suitab.raster)),
Xpop = as.vector(vs.test.resc[[20]]$suitab.raster),
Xmclim = as.vector(Pred.MX.dft[[20]])) %>%
  pivot_longer(cols = everything(),
               names_to = "raster",
               values_to = "value") %>%
ggplot(aes(x = value, y = raster, fill = raster)) +
  geom_density_ridges(scale = 2, alpha = .3) +
  #scale_fill_manual(values = c("#666666", "#FF0000")) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme(axis.text = element_text(size = 40)) +
  labs(title = "TEST",
           y = "Possible habitat status",
           x = "출현 확률/서식처 적합도",
           size = 20) +
  theme_ridges(grid = FALSE) -> ridge
```

```{r}
ggsave("ridge.svg",
  ridge, width = 36, height = 15, units = "cm", dpi = 400, limitsize = F) 
```


```{r}
data.frame(#"-10" = resid.MX.dft[[1]],
           "n9" = resid.MX.dft[[2]],
           "n8" = resid.MX.dft[[3]],
           "n7" = resid.MX.dft[[4]],
           "n6" = resid.MX.dft[[5]],
           "n5" = resid.MX.dft[[6]],
           "n4" = resid.MX.dft[[7]],
           "n3" = resid.MX.dft[[8]],
           "n2" = resid.MX.dft[[9]],
           "n1" = resid.MX.dft[[10]],
           "p0" = resid.MX.dft[[11]],  
           "p1" = resid.MX.dft[[12]],
           "p2" = resid.MX.dft[[13]],
           "p3" = resid.MX.dft[[14]],
           "p4" = resid.MX.dft[[15]],
           "p5" = resid.MX.dft[[16]],
           "p6" = resid.MX.dft[[17]],
           "p7" = resid.MX.dft[[18]],
           "p8" = resid.MX.dft[[19]],
           "p9" = resid.MX.dft[[20]]) %>%
  pivot_longer(cols = everything(),
               names_to = "pop.effect",
               values_to = "value") -> df.ridge.resid
df.ridge.resid$pop.effect <-  factor(df.ridge.resid$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9"))
df.ridge.resid %>%
  ggplot(aes(x = value, y = pop.effect, fill = pop.effect)) +
  geom_density_ridges(scale = 5, alpha = .3) +
  #gghighlight(pop.effect == "X0") +
  #scale_fill_manual(values = c("grey80", "grey80", "grey80", "grey80", "grey80",
  #                             "grey80", "grey80", "grey80", "grey80", "#red",
  #                             "grey80", "grey80", "grey80", "grey80", "grey80",
  #                             "grey80", ,"grey80" ,"grey80" ,"grey80", "grey80")) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme(axis.text = element_text(size = 40)) +
  labs(title = "TEST",
           y = "Density",
           x = "Population effect size",
           size = 20) +
  theme_ridges(grid = FALSE) -> ridge.resid
```

```{r}
ggsave("ridge.resid.svg",
  ridge.resid, width = 36, height = 35, units = "cm", dpi = 400, limitsize = F) 
```

```{r}
data.frame(
  rmse.dft = map2_dbl(vs.test.resc, Pred.MX.dft, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.KDE = map2_dbl(vs.test.resc, Pred.MX.KDE, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.clim = map2_dbl(vs.test.resc, Pred.MX.clim, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
auc.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.clim = map2_dbl(MX.clim, TEST.clim, function(x,y){SDMtune::auc(model = x, test = y)}),
pop.effect = c("n10", names.pop.effect)) -> df.eval
df.eval
```

```{r}
df.eval %>%
  select(c("auc.dft", "auc.KDE", "auc.clim", "pop.effect")) %>%
  pivot_longer(cols = !"pop.effect",
               names_to = "eval", 
               values_to = "value") -> df.eval.auc
df.eval.auc$pop.effect <- factor(df.eval.auc$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9",
           "n10"))
df.eval.auc %>%
group_by(eval) %>%
  ggplot(aes(pop.effect, value, colour = eval)) +
  geom_point(aes(size = 5, alpha = 0.8)) +
  theme(axis.text = element_text(size = 40)) +
  theme_light() +
  labs(
           y = "AUC",
           x = "Population effect size",
           size = 20) -> plot.auc
df.eval %>%
  select(c("rmse.dft", "rmse.KDE", "rmse.clim", "pop.effect")) %>%
  pivot_longer(cols = !"pop.effect",
               names_to = "eval", 
               values_to = "value")  -> df.eval.rmse
df.eval.rmse$pop.effect <- factor(df.eval.rmse$pop.effect,
                                             levels = c("p9",
           "p8",
           "p7",
           "p6",
           "p5",
           "p4",
           "p3",
           "p2",
           "p1",
           "p0",  
           "n1",
           "n2",
           "n3",
           "n4",
           "n5",
           "n6",
           "n7",
           "n8",
           "n9",
           "n10"))
df.eval.rmse %>%
  group_by(eval) %>%
  ggplot(aes(pop.effect, value, colour = eval, alpha = 0.8)) +
  geom_point(aes(size = 5)) +
  theme(axis.text = element_text(size = 40)) +
  theme_light() +
  labs(
           y = "RMSE",
           x = "Population effect size",
           size = 20) -> plot.rmse
```

```{r}
ggsave("plot.auc.svg",
    plot.auc,
    width = 25,
    height = 15, 
    units = "cm", dpi = 400, limitsize = F) 
ggsave("plot.rmse.svg",
    plot.rmse,
    width = 25,
    height = 15, 
    units = "cm", dpi = 400, limitsize = F) 
```


```{r}
rbind(
as.data.frame(resid.MX.dft,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "dft", .after = "apop"),
as.data.frame(resid.MX.KDE,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "KDE", .after = "apop")) %>%
  ggplot(aes(interpolation, value)) +
  geom_violin()
```
```{r}
rbind(
as.data.frame(resid.MX.dft,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "dft", .after = "apop"),
as.data.frame(resid.MX.KDE,
              col.names = apop) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "apop",
               values_to = "value") %>%
  mutate(interpolation = "KDE", .after = "apop")) %>%
  ggplot(aes(apop, value, fill = interpolation)) +
  geom_violin()
```
```{r}
data.frame(
  rmse.Xpop = map2_dbl(vs.lfun, Pred.MX.Xpop, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.XpopxXs1 = map2_dbl(vs.lfun, Pred.MX.XpopxXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.dft = map2_dbl(vs.lfun, Pred.MX.dft, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
  rmse.KDE = map2_dbl(vs.lfun, Pred.MX.KDE, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.KDExXs1 = map2_dbl(vs.lfun, Pred.MX.KDExXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
  rmse.xXs1 = map2_dbl(vs.lfun, Pred.MX.xXs1, function(x, y){
  Metrics::rmse(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.dft = map2_dbl(vs.lfun, Pred.MX.dft, function(x, y){
  Metrics::mae(actual = as.vector(x$suitab.raster),
                predicted = as.vector(y))}),
mae.KDE = map2_dbl(vs.lfun, Pred.MX.KDE, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.KDExXs1 = map2_dbl(vs.lfun, Pred.MX.KDExXs1, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
mae.xXs1 = map2_dbl(vs.lfun, Pred.MX.xXs1, function(x, y){
Metrics::mae(actual = as.vector(x$suitab.raster),
              predicted = as.vector(y))}),
auc.Xpop = map2_dbl(MX.Xpop, TEST.Xpop, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.KDExXs1 = map2_dbl(MX.KDExXs1, TEST.KDExXs1, function(x,y){SDMtune::auc(model = x, test = y)}),
auc.xXs1 = map2_dbl(MX.xXs1, TEST.xXs1, function(x,y){SDMtune::auc(model = x, test = y)}),
tss.dft = map2_dbl(MX.dft, TEST.dft, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.KDE, TEST.KDE, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.KDExXs1, TEST.KDExXs1, function(x,y){SDMtune::tss(model = x, test = y)}),
tss.KDE = map2_dbl(MX.xXs1, TEST.xXs1, function(x,y){SDMtune::tss(model = x, test = y)}),
prg.dft = map2(MX.dft, TEST.dft, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
                                #neg_scores = SDMtune::predict(x,
                                #                              y)[y@pa == 0])}) 
prg.KDE = map2(MX.KDE, TEST.KDE, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
prg.KDExXs1 = map2(MX.KDExXs1, TEST.KDExXs1, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg),
prg.xXs1 = map2(MX.xXs1, TEST.xXs1, function(x,y){prg::create_prg_curve(labels = y@pa,
                                pos_scores = SDMtune::predict(x,
                                                              y))}) %>% map_dbl(prg::calc_auprg)) -> df.eval
rbind(
  {dplyr::select(df.eval, ends_with("KDE")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "KDE")},
  {dplyr::select(df.eval, ends_with("dft")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
    mutate(interpolation = "dft")},
  {dplyr::select(df.eval, ends_with("KDExXs1")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "KDExXs1")},
  {dplyr::select(df.eval,  ends_with("xXs1") & !contains("KDE")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "xXs1")},
  {dplyr::select(df.eval,  ends_with("xXs1") & contains("Xpop")) %>%
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "XpopxXs1")},
  {dplyr::select(df.eval,  ends_with("Xpop")) %>% 
      pivot_longer(data = .,
                   cols = everything(),
                   names_to = "loss",
                   values_to = "value") %>%
      mutate(interpolation = "Xpop")}
  ) %>%
  ggplot(aes(loss, value, colour = interpolation, size = 10)) +
  geom_point() +
  labs(title = "Model evaluation metrics",
           y = "Value",
           x = "Evaluation metrics",
           size = 15) +
      theme_light() +
      theme(axis.text = element_text(size = 14),
            legend.position = "bottom", legend.direction = "horizontal")-> plot.eval
plot.eval
ggsave(plot = plot.eval, filename = "plot.eval.svg", width = 480, height = 120, units = "mm", dpi = 400, limitsize = FALSE)
```



```{r}
data.frame(KDE = align.KDE) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "interpolation",
               values_to = "value") %>%
  ggplot(aes(interpolation, value)) +
  geom_violin()
```





```{r}
rbind(vs.rnd$details$parameters[[1]]$args, vs.rnd$details$parameters[[2]]$args)
```
```{r}
rbind(vs.lfun[[4]]$details$parameters[[1]]$args, vs.lfun[[4]]$details$parameters[[2]]$args)
```




```{r}
map_dbl(vs.lfun, function(vs.l){
cor(as.vector(vs.rnd$suitab.raster - vs.l$suitab.raster), as.vector(Xs$layer.2))})
cor(as.vector(vs.lfun[[5]]$suitab.raster - vs.rnd$suitab.raster), as.vector(Xs$layer.2))
```







```{r}
set.seed(1)
vs.rnd %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.1) %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 1000,
                    type = "presence-absence") -> PA
PA$sample.points %>%
  filter(Real == 1) -> presence
presence %>% select(c("x", "y")) %>% sf::st_as_sf(coords = c("x", "y")#,
                                                    ) -> sf.presence
presence %>%
  select(c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 100),
                    yrange = c(0, 100)))} %>%
  {density.ppp(x = .,
               edge = FALSE,
          kernel = "gaussian",
          sigma = 7,
          dimyx = c(100,100),
          eps = c(1,1))} %>%
  raster() -> KDE.presence
#KS.b.1 %>% {raster(x = .$v,
##                   xmn = 0, 
##                   ymn = 0,
#                   xmx = 100,
#                   ymx = 100)} -> KS.b.1
```

```{r}
vs.rnd %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) -> PA
PA %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 6,
                    sample.prevalence = 0.5,
                    replacement = TRUE,
                    type = "presence-absence") -> occ
#3^(2:9)
#seq(10, 1000, by = 100)
purrr::accumulate(append(list(occ), seq(10, 100, by = 10)), function(occs, n){
occs$sample.points[occs$sample.points$Real == 1,c("x", "y")] %>%
 st_as_sf(coords = c("x", "y")) %>%
 st_buffer(., 
           dist = 5) %>%
  as_Spatial() %>%
  sampleOccurrences(PA,
                    bias = "polygon", 
                    bias.area = .,
                    extract.probability = TRUE,
                    n = n,
                    bias.strength = 500,
                    sample.prevalence = 0.5,
                    replacement = TRUE,
                    type = "presence-absence")}) -> bias.occ
```

```{r}
map(bias.occ, function(occs){
occs$sample.points %>%
  filter(Real == 1)}) -> presence
#presence %>% select(c("x", "y")) %>% sf::st_as_sf(coords = c("x", "y")#,
#                                                    ) -> sf.presence
presence %>%
map(function(presence){
  presence %>%
  select(c("x", "y")) %>%
{ppp(.$x, .$y, 
     #marks = dplyr::select(., "true.probability"),
      window = owin(xrange = c(0, 100),
                    yrange = c(0, 100)))} %>%
  Kest()}) -> L.presence
map(L.presence, plot)
```


```{r warning=FALSE}
tmap_arrange(
  tm_shape(KDE.presence) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom")),
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom")))
```
 

```{r}
tm_shape(Xs) +
  tm_raster()
```

[min=0; max=1] : linearFun   (a=-0.232323232323232; b=0.132171321713217)

```{r}
plotResponse(vs.rnd)
```


```{r}
SDMtune::prepareSWD(species = "VS1",
                    env = stack(Xs, KDE.presence),
                    p = presence[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000)) -> SWD
SDMtune::train(method = "Maxent",
               data = SWD) -> MX
```

```{r}
SDMtune::plotResponse(model = MX,
                      var = "layer.1")
SDMtune::plotResponse(model = MX,
                      var = "layer.2")
```

```{r}
SDMtune::predict(MX, stack(Xs, KDE.presence)) -> PRED.MX
```


```{r}
tmap_arrange(
  tm_shape(PRED.MX) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
    tm_layout(legend.position = c("right", "bottom")), # PRED map
  tm_shape(z) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() + 
  tm_layout(legend.position = c("right", "bottom")), # KDE map
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom"))) # HS map
```




## 

```{r}
SDMtune::prepareSWD(species = "VS1",
                    env = stack(Xs),
                    p = presence[,c("x", "y")],
                    a = dismo::randomPoints(Xs, 10000)) -> SWD.Xs
SDMtune::train(method = "Maxent",
               data = SWD.Xs,
               fc = c("l")) -> MX.Xs.L
SDMtune::train(method = "Maxent",
               data = SWD.Xs) -> MX.Xs.LQPH
```

```{r}
SDMtune::plotResponse(model = MX.Xs.L,
                      var = "layer")
```


```{r}
SDMtune::predict(MX.Xs.L, stack(Xs)) -> PRED.MX.Xs.L
```

```{r}
SDMtune::predict(MX.Xs.LQPH, stack(Xs)) -> PRED.MX.Xs.LQPH
```

```{r}
tmap_arrange(
  tm_shape(PRED.MX.Xs) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
    tm_layout(legend.position = c("right", "bottom")), # PRED map
  tm_shape(KDE.presence) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() + 
  tm_layout(legend.position = c("right", "bottom")), # KDE map
  tm_shape(vs.rnd$suitab.raster) +
    tm_raster() +
  tm_shape(sf.presence) +
    tm_dots() +
  tm_layout(legend.position = c("right", "bottom"))) # HS map
```

```{r}
(vs.rnd$suitab.raster - PRED.MX.Xs.L) %>% as.vector() -> resid.Xs.L
(vs.rnd$suitab.raster - PRED.MX.Xs.LQPH) %>% as.vector() -> resid.Xs.LQPH
data.frame(XL.L = resid.Xs.L,
           Xs.LQPH = resid.Xs.LQPH) %>%
  pivot_longer(data = .,
               cols = everything(),
               names_to = "fc",
               values_to = "value") %>%
  ggplot(aes(fc, value)) +
  geom_violin()
```

```{r}
((10000*KDE.presence*Xs) + 0.132171321713217) -> z
```


set.seed(1)
a[[1]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    extract.probability = T,
                    n = 600,
                    type = "presence-absence") -> b.1.1


b.1$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.1

sf.b.1 %>%  
  st_buffer(5) -> buf.b.1


tm_shape(a[[1]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.1) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.1) +
  tm_dots() +
tm_layout(legend.outside = TRUE)-> tm.b1
tm.b1















a[[2]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "polygon",
                    bias.area = as_Spatial(buf.b.1),
                    bias.strength = 5,
                    extract.probability = T,
                    n = 600,
                    type = "presence-absence") -> b.2

b.2$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.2

sf.b.2 %>%  
  st_buffer(5) -> buf.b.2

tm_shape(a[[2]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.2) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.2) +
  tm_dots() +
tm_layout(legend.outside = TRUE)-> tm.b2
tm.b2



a[[3]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "polygon",
                    bias.area = as_Spatial(buf.b.2),
                    bias.strength = 5,
                    extract.probability = T,
                    n = 900,
                    type = "presence-absence") -> b.3

b.3$sample.points %>%
  filter(Real == 1) %>%
  st_as_sf(coords = c("x", "y")) -> sf.b.3

sf.b.3 %>%  
  st_buffer(5) -> buf.b.3


tm_shape(a[[3]]$suitab.raster) +
  tm_raster(palette = "viridis") +
tm_shape(buf.b.3) +
  tm_polygons(alpha = 0.2) +
tm_shape(sf.b.3) +
  tm_dots() +
tm_layout(legend.outside = TRUE) -> tm.b3
tm.b3

tmap_arrange(tm.b1, tm.b2, tm.b3)

첫번째 지도(tm.1)는 출현 자료의 공간구조가 서식처 적합도에 영향을 못주는 형태
두번째 지도(tm.2)는 출현 자료의 공간구조가 반응함수를 수정했고(사실 내가 수정함)
그 반응함수에 따라 서식처 적합도가 재계산되었으며(사실 새로 종 만듬)
해당 서식처 적합도 내에서 출현 자료가 재수집되나 기존 출현자료인근에서 더 자주 수집되도록 설정하였음.


a[[4]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "manual",
                    weights = a[[4]]$suitab.raster,
                    extract.probability = T,
                    n = 1200,
                    type = "presence-absence") -> b.4

a[[5]] %>%
  convertToPA(., 
               PA.method = "probability",
               prob.method = "linear",
               species.prevalence = 0.3) %>%
  sampleOccurrences(.,
                    bias = "manual",
                    weights = a[[5]]$suitab.raster,
                    extract.probability = T,
                    n = 1500,
                    type = "presence-absence") -> b.5



#  convertToPA(., 
#               PA.method = "probability",
#               prob.method = "linear",
#               species.prevalence = 0.5) %>%
#  sampleOccurrences(.,
#                    extract.probability = T,
#                    n = 600,
#                    type = "presence-absence")}) -> Occs

#map(a, plotResponse)
list(b.1, b.2, b.3) %>% map(function(x){st_as_sf(x$sample.points, coords = c("x", "y"))}) %>%
  map(function(x){plot(x["Real"])})




map(a, function(x){plot(x$suitab.raster)})-> c